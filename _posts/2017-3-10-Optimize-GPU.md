---
layout: post
title: "项目优化之针对GPU"
date: 2017-3-10
image: '/assets/img/'
description: '在项目中对GPU方面进行优化.'
tags:
- 优化
- GPU
categories:
- 优化 
---

> GPU负责整个渲染流水线，它会对CPU传过来的数据进行一系列的计算，最后输出到屏幕上。因此，从顶点，像素，带宽等方面对GPU进行优化。

#### 顶点优化

&#8194;&#8194;&#8194;&#8194;顶点计算是指GPU必须对每个网格上的顶点进行的计算操作，顶点计算主要受到两个因素的影响：需要计算的顶点数量，每个顶点需要进行的操作。

1、优化几何体  
&#8194;&#8194;&#8194;&#8194;剔除不必要的复杂网格，对于不在视图中的物体，不需要过多的细节网格。可以创建面数较低的模型来替代高模。

2、LOD（level of detail）技术  
&#8194;&#8194;&#8194;&#8194;根据摄像机距离对象的远近，选择不同精度的模型，目的是降低显卡的负荷，但缺点是占用更多的内存。  
&#8194;&#8194;&#8194;&#8194;建议在建模软件中按照精度由高向低地为模型命名为"模型名字_LOD0"，"模型名字_LOD1"等等，最后的序号越低代表模型精度越高。这样的命名规则可以让unity自动为模型添加LOD组（LOD Group）。导出fbx之前，需要让这两个模型位置重合，其他导出设置与普通模型导出一致。

3、遮挡剔除（occlusion culling)技术  
&#8194;&#8194;&#8194;&#8194;遮挡剔除是用来消除在其他物体后面看不到的物体，不用再对那些看不到的顶点进行计算，进而提升性能。  
&#8194;&#8194;&#8194;&#8194;在默认的渲染管线中，会根据摄像机的视锥体范围对场景模型进行剔除操作，在视锥体以外的物体不被渲染。在视锥体以内的物体会以离摄像机最远的物体开始渲染，再逐渐渲染靠近摄像机的物体，后渲染的物体会覆盖先渲染的物体，这种技术称为视锥体剔除。    
&#8194;&#8194;&#8194;&#8194;但视锥体剔除只会剔除摄像机视角以外的物体，而对于视角内但被其他物体遮挡的物体还是会渲染。而遮挡剔除是剔除一个在摄像机视角内被其他物体遮挡的物体，使其不被渲染。  
**原理：**  
&#8194;&#8194;&#8194;&#8194;在场景空间中创建一个遮挡区域，该遮挡区域由单元格（cell）组成，这些单元格会把场景拆成多个部分。当摄像机能看到该单元格时，该单元格中的物体会被渲染。而被其他单元格遮挡住的单元格中的物体将不会被渲染。  
**步骤**  
- 自动生成遮挡剔除  
    1. 选择场景中需要生成遮挡剔除的物体下的所有子物体，在Inspector窗口勾上static选项，把该对象设置为静态物体，父物体不要设置为静态物体，静态类型设置为“Occluder Static”和“Occludee Static”。
    2. 选择“Window”->“Occlusion Culling”，打开遮挡剔除面板，在Scene中会添加被划分为多个单元格的包围体。点击“Bake”按钮，等待遮挡区域生成完毕。
    3. 在Scene窗口的右下角有一个遮挡剔除测试面板，把Edit改为Visualization，移动场景中的摄像机，在Scene中会显示当前被剔除的效果，这时帧速率也会因为渲染量的减少而大幅度增加。
- 手动生成遮挡剔除
    1. 新建一个空的游戏对象OcclusionAreaObject，为其添加一个Occlusion Area组件，设置Occlusion Area的范围使其能覆盖需要遮挡剔除的区域，场景中的其他必要对象都要设置为静态的。
    2. 打开遮挡剔除面板，点击“Bake”按钮生成遮挡区域。
    3. 在遮挡剔除测试面板中，把Edit改为Visualization模式，观察遮挡剔除效果。
- 入口遮挡剔除  
    使用入口遮挡可以动态的通过脚本控制使某个物体是否拥有遮挡剔除效果。
    1. 为A对象添加Occlusion Portal组件，并把它的open属性取消勾选，A不需要进行“遮挡烘焙”，因为A不要受到系统遮挡剔除的效果。并且要保证摄像机不能看到A后面的所有对象。
    2. 在A上添加一个脚本，用代码控制open属性的开启关闭。

4、层消隐  
&#8194;&#8194;&#8194;&#8194;通过给每个层（layer）设置一个可以看见的距离，当摄像机与设置该层的物体的距离超过这个值，该物体将不会再被渲染。
* 代码如下：
```csharp
    private float[] layers;
    layers=new float[32];
    layers[8]=10;
    layers[9]=20;
    Camera.main.layerCullDistance=layers;
```

#### 像素优化

1、减少overdraw  
&#8194;&#8194;&#8194;&#8194;overdraw是指相同的像素被多次渲染，因此要控制绘制顺序。

2、减少实时光照  
&#8194;&#8194;&#8194;&#8194;使用光照贴图Lightmaps。如果使用unity自带的shader，在表现不差的情况下选择Mobile或Unlit目录下的，它们更高效。


#### 带宽优化

&#8194;&#8194;&#8194;&#8194;带宽是指GPU在其特定的内存上的读写速率。  
  
1、压缩纹理贴图  
&#8194;&#8194;&#8194;&#8194;压缩贴图比未压缩的32位RGBA贴图占用内存带宽少得多，大大提高渲染表现。

2、mipmap(多重纹理格式）  
&#8194;&#8194;&#8194;&#8194;可以为游戏的贴图生成多重纹理贴图，远处显示较小的物体用小的贴图，显示较大的物体用精细的贴图，这样能更加有效的减少传输给GPU的数据。

#### 锁定帧率
&#8194;&#8194;&#8194;&#8194;在ProjectSetting->Quality中的VSync Count参数会影响FPS，EveryVBlank相当于FPS=60，EverySecondVBlank=30。

如果需要手动调整FPS，先关闭垂直同步，然后在Awake方法里手动设置FPS,
* 代码如下：
```csharp
    Application.targetFrameRate = 45;
```

降低FPS的好处：可以省电，减少手机发热；稳定游戏FPS，减少卡顿的情况。

待机时，调整游戏的FPS为1，节省电量。

#### 渲染路径（Rendering Path）
&#8194;&#8194;&#8194;&#8194;渲染路径用于灯光和阴影在场景中的计算方法，不同的渲染路径具有不同的性能特效和渲染效果。    
渲染路径分类：
- 顶点光照（vertex lit）
- 向前渲染（forward rendering）
- 延时光照（deferred lighting）

1. **顶点光照**是最低保真度的光照，不支持实时阴影的渲染路径。支持顶点光照渲染路径只对所有物体渲染一次（或称为一个通道pass，或者一个渲染阶段），所有光源的照明都是在物体的顶点上计算的。因此，此渲染路径不支持大部分的逐像素渲染效果：如阴影、法线贴图、灯光遮罩、高精度的高光。一般用于硬件比较差的机器。
2. **向前渲染**是基于着色器的渲染路径，支持逐像素计算光照（包括法线贴图和灯光cookies）以及来自一个平行光的实时阴影。
3. **延时光照**是具有最高保真度的光照和阴影的渲染途径。如果场景中有很多实时灯光，最好使用延时光照。但它需要一定的硬件支持，目前移动设备上不支持改渲染路径。影响它计算性能的因素分别是被照亮的物体在屏幕上的像素数量和投射阴影的灯光的数量。  
    - 优点：  
    &#8194;&#8194;&#8194;&#8194;对于能影响物体的光线数量没有上限，完全采用以每像素的方式进行光线计算，这意味着场景中所有灯光将以正常的光照模式作用于物体的材质上，从而保证灯光计算的一致性；所有光线都能使用灯光cookies，都能产生阴影；不必担心光线所照射的物体数量。
    - 缺点：  
    &#8194;&#8194;&#8194;&#8194;没有实时抗锯齿支持；不能处理半透明物体，也不能用在那些使用向前渲染的物体上；不能取消物体的接受阴影属性（receive shadow），也就是说物体将永远接受其他物体所投射的阴影；灯光中的Culling Mask属性设置也会失效。

---
*注：以上内容来源于网上搜集整理*

